# Quorum

法定人数是确保一致性（安全性）的关键抽象，任何仲裁都可以在其他进程失败的情况下取得进展。

为了在分布式系统中达成一致或执行某些操作所需要的最小数量的参与者（通常是进程或节点）。这个概念源自政治和法律领域，其中"Quorum"指的是进行有效投票或会议的最小出席人数。

## 属性

1. **安全性（Safety）**
   - **多数法定人数**：为了保证安全性，一个Quorum通常被定义为系统中大多数进程的集合。这意味着任何两个Quorums都至少有一个共同的进程。这个属性防止了所谓的“分脑”问题（Split-Brain Problem）。
   - **分脑问题**：在分布式系统中，如果系统被分成两个或多个彼此不通信的部分，且每个部分都认为自己是完整的系统并独立操作，就会发生分脑问题。这可能导致数据不一致和其他错误。通过要求多数法定人数，可以确保系统不会在无法通信的子集中独立作出决策。

2. **活性（Liveness）**
   - **即使少数进程失败**：即便系统中有少数进程失败，仍然总会存在至少一个只包含正确进程的Quorum。这意味着系统仍然可以继续进行操作和决策，保证了活性。
   - **保证活性**：这个属性确保了即使在面对部分故障的情况下，系统仍然能够正常工作，可以执行必要的操作，如数据读写、状态更新等。

## 安全性和活性的结合

1. **活性（Liveness）**
   - **N−f个进程可以取得进展**：这意味着即使有f个进程发生故障，剩余的N−f个进程应该足够形成一个Quorum，从而使系统能够继续进行必要的操作，如数据读写或状态更新。
   - **Quorum大小**：这里的关键是确保Quorum的大小设置为不超过N−f，这样即使f个进程崩溃，系统中仍然有足够的进程来形成一个有效的Quorum。

2. **安全性（Safety）**
   - **任意两个Quorum至少有一个正确的进程相交**：为了确保安全性，任意两个Quorum都应至少有一个正确的进程共同参与。这可以防止“分脑”问题，保证系统不会做出矛盾的决策。
   - **推导公式**：`2(N−f) > N`，即两个Quorum（每个至少N−f个进程）的总大小超过了系统总大小N，确保了它们至少有一个共同的进程。
   - **进程数限制**：由此可推导出`N > 2f`，即系统中的总进程数N必须大于两倍的可能故障数f。为了满足整数的要求，我们进一步得到`N ≥ 2f+1`。

综上所述，为了同时满足安全性和活性，系统的总进程数N需要至少是可能故障数f的两倍加一。

## 拜占庭故障情况下Quorum

拜占庭故障是指系统中的一部分节点可能出现任意类型的错误行为，包括发送错误或矛盾的信息。

1. **对于任意两个Quorum的交集**
   - 在拜占庭Quorum系统中，任何两个Quorum `Q_1` 和 `Q_2` 的交集至少要包含`f+1`个进程，其中`f`是可能的拜占庭故障的数量。这是为了确保至少有一个正确的（非拜占庭）进程出现在任何两个Quorum的交集中。

2. **活性（Liveness）**
   - 即使存在`f`个拜占庭故障，`N-f`个正确的进程仍然可以取得进展，形成一个有效的Quorum。

3. **安全性（Safety）**
   - 安全性要求在考虑拜占庭故障的情况下，任意两个Quorum都至少有一个正确的进程相交。
   - 为了确保安全性，必须满足`2(N-f) > N+f`，即两个没有拜占庭故障的Quorum的大小之和要大于总进程数加上可能的拜占庭故障数。
   - 这可以推导出`N > 3f`，即系统中的总进程数N必须大于拜占庭故障数f的三倍。为了满足整数的要求，我们进一步得到`N ≥ 3f+1`。

# Majority-Ack Uniform Reliable Broadcast

1. **在没有完美故障检测器的情况下实现URB**：
   - **使用Quorum系统**：在一个假设大多数进程是正确的系统中（即`N > 2f`，其中`N`是进程总数，`f`是可能的故障进程数），可以使用基于Quorum的方法来实现URB。这种方法不依赖于完美的故障检测，而是通过确保任何两个Quorums至少有一个共同的正确进程来维护一致性。
   - **Quorum的作用**：在这种设置中，Quorum充当一种达成共识的机制，确保消息被大多数正确的进程接收和确认。由于任何两个Quorums都至少有一个共同的正确进程，这保证了消息的一致性和完整性。

## 实现

```c
Implements: UniformReliableBroadcast, instance urb.
Uses: BestEffortBroadcast, instance beb.

# 当统一可靠广播系统初始化时触发的事件
upon event < urb, Init > do
    delivered := ∅;  # 初始化delivered集合，用于跟踪已交付的消息
    pending := ∅;  # 初始化pending集合，用于存储待处理的消息
    for all m do ack[m] := ∅;  # 为每个消息m初始化一个空集合，用于跟踪确认接收消息的进程

# 当有广播消息请求时触发的事件
upon event < urb, Broadcast | m > do
    pending := pending ∪ {(self, m)};  # 将消息添加到pending集合
    trigger < beb, Broadcast | [DATA, self, m] >;  # 通过尽力而为广播发送消息

# 当尽力而为广播传递消息时触发的事件
upon event < beb, Deliver | p, [DATA, s, m] > do
    ack[m] := ack[m] ∪ {p};  # 记录确认接收消息m的进程p
    if (s, m) not in pending then
        pending := pending ∪ {(s, m)};  # 如果消息不在pending集合中，则添加
        trigger < beb, Broadcast | [DATA, s, m] >;  # 重新广播消息

# 判断消息m是否可以交付的函数
function candeliver(m) returns Boolean is
    return #(ack[m]) > N/2;  # 如果确认接收消息m的进程数超过一半，则返回true

# 当存在可交付的消息时触发的事件
upon exists (s, m) ∈ pending such that candeliver(m) ∧ m not in delivered do
    delivered := delivered ∪ {m};  # 将消息标记为已交付
    trigger < urb, Deliver | s, m >;  # 交付消息m
这个算法的核心思想是：
当一个进程广播一条消息时，它将消息添加到待处理集合pending中，并通过尽力而为广播发送这条消息。
当一个进程接收到一条消息时，它会记录已确认接收这条消息的进程。如果这条消息尚未加入到待处理集合pending中，则加入该消息并重新广播。
一个消息只有在超过系统中一半以上的进程都确认接收后，才被认为是可以交付的。这通过candeliver函数来判断。
当一个消息可以被交付时，它会被从pending集合移动到delivered集合，并触发交付事件。
```

## 正确性

正确性涵盖了有效性、无重复、无创造和统一协议的几个关键方面。

1. **有效性（Validity）**
   - 如果发送者是正确的（即没有发生故障），那么每个正确的进程都会交付这个DATA消息。
   - 这里的有效性包括几个部分：
     - 每个正确的进程都会交付DATA消息。
     - 每个正确的进程都会广播DATA消息。
     - 每个正确的进程都会交付超过`N/2`个DATA消息，这是因为大多数进程是正确的（根据`N > 2f`，即进程总数大于故障进程数的两倍加一）。

2. **无重复、无创造（No Duplication, No Creation）**
   - 这部分相对直接。系统确保每个消息只被交付一次（无重复），且每个交付的消息都是由某个进程广播的（无创造）。

3. **统一协议（Uniform Agreement）**
   - 假设`N = 2f + 1`，其中`f`是可能的故障进程数。
   - 假设一个正确的进程`p1`以某种方式交付了消息`m`。
   - 为了交付`m`，`p1`必须至少接收到`f + 1`个关于`m`的DATA消息，这至少包括一个来自正确进程的DATA消息。
   - 这个正确进程的DATA消息也会被剩余的`f`个正确进程交付，然后它们会广播这个DATA消息。
   - 因此，每个正确的进程最终都会交付消息`m`，因为至少有`f + 1`个正确的进程已经发送了一个DATA消息。

## 表现

1. **最佳情况**
   - **通信步骤**：两个通信步骤。**消息数量**：O(N²)条消息，其中N是系统中进程的总数。
   - **解释**：在最佳情况下，每个进程都能迅速接收到其他所有进程的消息，并且每个进程都只需要发送和接收一轮消息。因此，总共需要两轮通信步骤：一轮用于发送消息，另一轮用于接收消息。每轮中，每个进程都会发送和接收大约N条消息，因此总消息数量是O(N²)。
2. **最坏情况**
   - **通信步骤**：N/2+2步。**消息数量**：O(N²)条消息。
   - **第1步**：原始的广播。每个进程发送它的消息。
   - **第2步至N/2+1步**：处理确认和可能的重传。在这些步骤中，进程们交换消息确认，以及可能的重传请求和重传消息。在最坏情况下，我们假设这个过程需要N/2步，因为可能有进程未能在前几轮通信中接收到某些消息。
   - **第N/2+2步**：最后的确认。在这一步中，确保所有正确的进程都已收到并确认了所有消息。
   - **解释**：最坏情况下，可能需要等待一定时间才能收到足够多的确认，以确保每个消息被大多数进程接收。因此，总共需要N/2+2轮通信步骤。在每一步中，系统的消息交换量仍然大约是O(N²)。

# Byzantine-tolerant broadcast

## Consistent broadcast primitives

## Reliable broadcast primitives

